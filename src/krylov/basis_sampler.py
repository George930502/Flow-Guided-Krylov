"""
Krylov Basis Sampler for CUDA-Q integration.

This module provides the interface between the classical NF-NQS
training and the quantum circuit execution via CUDA-Q.

The sampler prepares and measures Krylov states using Trotterized
time evolution circuits.
"""

import numpy as np
from typing import List, Dict, Tuple, Optional, Callable
from dataclasses import dataclass


@dataclass
class CUDAQConfig:
    """Configuration for CUDA-Q execution."""

    target: str = "nvidia"  # CUDA-Q target
    seed: int = 42
    shots: int = 100000
    num_trotter_steps: int = 8
    time_step: float = 0.1


class KrylovBasisSampler:
    """
    Krylov basis sampler using CUDA-Q circuits.

    This class provides an interface for sampling from Krylov states
    on quantum hardware or GPU-accelerated simulation via CUDA-Q.

    The Krylov states are generated by time evolution:
        |ψ_k⟩ = U^k |ψ_0⟩ where U = e^{-iHΔt}

    The time evolution is implemented via Trotter decomposition
    using the exp_pauli operation in CUDA-Q.

    Args:
        pauli_coefficients: List of Hamiltonian term coefficients
        pauli_words: List of Pauli strings (as CUDA-Q pauli_word)
        num_qubits: Number of qubits
        config: CUDA-Q execution configuration
    """

    def __init__(
        self,
        pauli_coefficients: List[float],
        pauli_words: List[str],
        num_qubits: int,
        config: Optional[CUDAQConfig] = None,
    ):
        self.pauli_coefficients = pauli_coefficients
        self.pauli_words = pauli_words
        self.num_qubits = num_qubits
        self.config = config or CUDAQConfig()

        self._cudaq_available = self._check_cudaq()

    def _check_cudaq(self) -> bool:
        """Check if CUDA-Q is available."""
        try:
            import cudaq
            return True
        except ImportError:
            return False

    def sample_krylov_state(
        self,
        krylov_power: int,
        initial_state: str = "neel",
    ) -> Dict[str, int]:
        """
        Sample from Krylov state |ψ_k⟩ = U^k |ψ_0⟩.

        Args:
            krylov_power: Power k in U^k
            initial_state: Initial state preparation ("neel", "all_zeros", etc.)

        Returns:
            Dictionary mapping bitstrings to counts
        """
        if self._cudaq_available:
            return self._sample_cudaq(krylov_power, initial_state)
        else:
            return self._sample_classical(krylov_power, initial_state)

    def _sample_cudaq(
        self,
        krylov_power: int,
        initial_state: str,
    ) -> Dict[str, int]:
        """
        Sample using CUDA-Q.

        Implements the Krylov circuit from AGENTs.md using exp_pauli for
        Trotterized time evolution.
        """
        import cudaq

        cudaq.set_target(self.config.target)
        cudaq.set_random_seed(self.config.seed)

        # Convert Pauli words to cudaq format
        pauli_words_cudaq = [
            cudaq.pauli_word(pw) for pw in self.pauli_words
        ]

        # Map initial state to integer flag (CUDA-Q kernels can't capture strings)
        # 0 = all zeros, 1 = neel state, 2 = all ones
        if initial_state == "neel":
            init_state_flag = 1
        elif initial_state == "all_ones":
            init_state_flag = 2
        else:
            init_state_flag = 0  # all zeros

        @cudaq.kernel
        def krylov_circuit_neel(
            num_qubits: int,
            krylov_power: int,
            trotter_steps: int,
            dt: float,
            h_pauli_words: list[cudaq.pauli_word],
            h_coeffs: list[float],
        ):
            """Krylov circuit with Néel state initialization."""
            qubits = cudaq.qvector(num_qubits)

            # Prepare Néel state |010101...> (alternating)
            for i in range(num_qubits):
                if i % 2 == 0:
                    x(qubits[i])

            # Time evolution: U^k where U = e^{-iHΔt}
            for _ in range(krylov_power):
                for _ in range(trotter_steps):
                    for j in range(len(h_coeffs)):
                        exp_pauli(-h_coeffs[j] * dt, qubits, h_pauli_words[j])

            mz(qubits)

        @cudaq.kernel
        def krylov_circuit_zeros(
            num_qubits: int,
            krylov_power: int,
            trotter_steps: int,
            dt: float,
            h_pauli_words: list[cudaq.pauli_word],
            h_coeffs: list[float],
        ):
            """Krylov circuit with all-zeros initialization."""
            qubits = cudaq.qvector(num_qubits)

            # Initial state is |00...0> (no gates needed)

            # Time evolution: U^k where U = e^{-iHΔt}
            for _ in range(krylov_power):
                for _ in range(trotter_steps):
                    for j in range(len(h_coeffs)):
                        exp_pauli(-h_coeffs[j] * dt, qubits, h_pauli_words[j])

            mz(qubits)

        @cudaq.kernel
        def krylov_circuit_ones(
            num_qubits: int,
            krylov_power: int,
            trotter_steps: int,
            dt: float,
            h_pauli_words: list[cudaq.pauli_word],
            h_coeffs: list[float],
        ):
            """Krylov circuit with all-ones initialization."""
            qubits = cudaq.qvector(num_qubits)

            # Prepare |11...1>
            for i in range(num_qubits):
                x(qubits[i])

            # Time evolution: U^k where U = e^{-iHΔt}
            for _ in range(krylov_power):
                for _ in range(trotter_steps):
                    for j in range(len(h_coeffs)):
                        exp_pauli(-h_coeffs[j] * dt, qubits, h_pauli_words[j])

            mz(qubits)

        # Select appropriate kernel based on initial state
        if init_state_flag == 1:
            kernel = krylov_circuit_neel
        elif init_state_flag == 2:
            kernel = krylov_circuit_ones
        else:
            kernel = krylov_circuit_zeros

        # Execute circuit
        result = cudaq.sample(
            kernel,
            self.num_qubits,
            krylov_power,
            self.config.num_trotter_steps,
            self.config.time_step,
            pauli_words_cudaq,
            self.pauli_coefficients,
            shots_count=self.config.shots,
        )

        return dict(result.items())

    def _sample_classical(
        self,
        krylov_power: int,
        initial_state: str,
    ) -> Dict[str, int]:
        """
        Classical simulation fallback when CUDA-Q is not available.

        This uses exact matrix exponentiation for small systems.
        """
        print("Warning: CUDA-Q not available, using classical simulation")

        # Build Hamiltonian matrix from Pauli strings
        H = self._build_hamiltonian_matrix()

        # Initial state
        if initial_state == "neel":
            psi0_idx = sum(
                2**i for i in range(0, self.num_qubits, 2)
            )
        else:
            psi0_idx = 0

        psi = np.zeros(2**self.num_qubits, dtype=complex)
        psi[psi0_idx] = 1.0

        # Time evolution
        dt = self.config.time_step
        U = np.linalg.matrix_exp(-1j * dt * H)

        for _ in range(krylov_power * self.config.num_trotter_steps):
            psi = U @ psi

        # Sample
        probs = np.abs(psi)**2
        probs /= probs.sum()

        indices = np.random.choice(
            len(probs), size=self.config.shots, p=probs
        )
        unique, counts = np.unique(indices, return_counts=True)

        results = {}
        for idx, count in zip(unique, counts):
            bitstring = format(idx, f"0{self.num_qubits}b")
            results[bitstring] = int(count)

        return results

    def _build_hamiltonian_matrix(self) -> np.ndarray:
        """Build Hamiltonian matrix from Pauli strings."""
        n = 2**self.num_qubits
        H = np.zeros((n, n), dtype=complex)

        # Pauli matrices
        I = np.eye(2, dtype=complex)
        X = np.array([[0, 1], [1, 0]], dtype=complex)
        Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
        Z = np.array([[1, 0], [0, -1]], dtype=complex)

        pauli_map = {"I": I, "X": X, "Y": Y, "Z": Z}

        for coeff, pauli_word in zip(self.pauli_coefficients, self.pauli_words):
            # Build tensor product
            term = np.array([[1.0]], dtype=complex)
            for p in pauli_word:
                term = np.kron(term, pauli_map[p])

            H += coeff * term

        return H

    def sample_all_krylov_states(
        self,
        max_krylov_dim: int,
        initial_state: str = "neel",
    ) -> List[Dict[str, int]]:
        """
        Sample from all Krylov states k = 0, 1, ..., max_k - 1.

        Args:
            max_krylov_dim: Maximum Krylov dimension
            initial_state: Initial state preparation

        Returns:
            List of sample dictionaries
        """
        samples = []
        for k in range(max_krylov_dim):
            samples.append(self.sample_krylov_state(k, initial_state))
        return samples


def create_cudaq_sampler(
    hamiltonian: "Hamiltonian",
    config: Optional[CUDAQConfig] = None,
) -> KrylovBasisSampler:
    """
    Factory function to create CUDA-Q sampler from Hamiltonian.

    Args:
        hamiltonian: System Hamiltonian
        config: CUDA-Q configuration

    Returns:
        KrylovBasisSampler instance
    """
    try:
        from ..hamiltonians.spin import extract_coeffs_and_paulis
    except ImportError:
        from hamiltonians.spin import extract_coeffs_and_paulis

    coeffs, paulis = extract_coeffs_and_paulis(hamiltonian)

    return KrylovBasisSampler(
        pauli_coefficients=coeffs,
        pauli_words=paulis,
        num_qubits=hamiltonian.num_sites,
        config=config,
    )
